console.log(2 + "2" == "2" + 2); /* true 
потому что здесь происходит конкатенация строк, а точнее числа и строки, 
ибо число переобразовываеться в строку оператором + а потом конкатенирует получившиеся строки
и по итогу имеем "22" == "22"
оператор == при сравнении именно двух строк между собой конвертирует их в код Unicode и тогда уже приравниваються между собой их значение
JS использует так называемый Алфавитный Порядок (дальше АП), а так как значения в Unicode 
правого и левого операнда равны то и оператор сравнения возвращает true
Дальше с Вашего позволения будет меньше текста, буду описывать только что то новое, а все не описанное ссылаеться на описаное выше :)
*/
console.log(2 + "3" == "3" + 2); /* false
 имеем "23" == "32" 
 оператор сравнение возвращает false, по скольку левый и правый операнд не равны по значению АП
*/
console.log("3" + "2" == 3 + 2); /*false 
имеем конкатенацию строк и прибавление чисел "32" == 3+2 -> "32" == 5 
операнды не равны между собой 
*/
console.log("3" + "2" == "3" + 2); /* true 
имеем "32" == "32"
*/
console.log("3" + "2" == 2 + "3"); /* false
имеем "32" == "23"
*/
console.log(2 + Number("3") == Number("3") + 2); /* true
Number([string]) - переобразовывет [string] в число если это возможно, если нет, то вернет NaN
в даном случае переобразование возможно, поэтому имеем 2+3 == 3 +2 -> 5 == 5
*/

console.log(12 / "6");  /* 2
 оператор деления делит левый операнд на правый и возвращает разницу
при этом оператор переобразовывет строки в числовые значения, а если это не возможно вернет NaN
*/
console.log("number" + 16 + 3);  /* number163
конкатинация строк с преобразованием чисел в строки оператором +
идем слева на право, поэтому 16 и 3 не прибавляються, ибо доходя к числу 3
слева от него мы уже имеем  "number16" и оператор + переобразовывает 3 в строку,
как 16 перед ним и поэтому имеем такой результат
*/
console.log(15 + 3 + "number");  /* 18number
здесь из-за другого порядка первый оператор + прибавил 2 числа 
а второй оператор + уже сделал конкатинацию строк
*/
console.log([1] > null);  /* true 
здесь у нас масив с всего одним элементом, JS ведет себя с такими масивами при некторых операциях (например как сравнине, больше, меньше)
 буд-то просто со значением игнорируя что оно в масиве, так как такие масивы позволяют быть переобразоваными в числовые значения,
   тоесть было бы там 2 элемента даная операция вернула бы false
 поскольку масив тогда был бы переобразован в NaN
*/
console.log("foo" + + "bar");  /* fooNaN
здесь конкатинация строки "foo" и свойтсво NaN, оно переобразовалось в строку "NaN"
NaN появилось в резуьтате того что возле строки "bar" стоит унарный + который переобразовывает строку в число
а если это не возможно то возвращает NaN
*/
console.log('true' == true);  /* false
оператор сравнение пытаеться конвертировать значения в числовые, поэтому, конвертирует строку 'true' в NaN а true в 1
поэтому имеем NaN == 1, естественно они не равны
*/
console.log(false == 'false');  /* false
тоже что и в примере выше, ведь NaN и false не равны друг другу, даже как NaN и NaN не равны между собой
*/
console.log(null == '');  /* false
так как получаем undefined == 0 а они не равны между собой
*/
console.log(!!"false" == !!"true");  /* true
оператор ! сначала переобразовывает строку к булеовму значению true, а потом следующий оператор ! переобразовывает
булевое значение true в false, и по итогу имеем false == false, а это канешно же равно
*/
console.log([`x`] == `x`);  /* true
я уже описывал поведение при сравнинии массива с одним элементом, как видим на этом примере со строковыми элементами 
это тоже отлично работает, поэтому по факту имеем сравниние двух строк `x` == `x`, а это равно
*/

// Задание 2

const enemy = {
    name: "Bob"
};

const friend = {
    name: "Alex"
};

const me = friend;

me.name = "Bob";

console.log(friend.name); // Bob 
/*мы присвоили переменой me объект friend, а это значит они теперь разделяют одну ячейку памяти и теперь любие изменения в объекте
me так же явно отразяться на объекте friend по факту они теперь равны друг другу по ссылке
мы явно присвоили свойтсву name объекта me строку "Bob", а свойства объекта в JS могут изменять, несмотря на то что сам объект
был объявлен как const - неизменяемый, по факту теперь тип перменной не измениться с объекта на другой, ну и другой объект теперь тоже
не назначить для me, а свойства вполне мутабельны*/
console.log(me == friend); // true
/*мы присвоили переменой me объект friend, а это значит они теперь разделяют одну ячейку памяти и теперь любие изменения в объекте
me так же явно отразяться на объекте friend по факту они теперь равны друг другу по ссылке
тоесть оператор сравнения при применении на объектах сравнивает их по тому где они находяться в памяти*/
console.log(me == enemy); // false
/*эти объекты не наохядться на одной ячейке в памяти*/